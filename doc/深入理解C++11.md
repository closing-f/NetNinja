<font size=5>
<!--
 * @Author: closing
 * @Date: 2023-06-16 09:27:18
 * @LastEditors: closing
 * @LastEditTime: 2023-09-01 17:17:13
 * @Description: 请填写简介
-->

### 右值引用

#### 拷贝构造和移动构造
1. 拷贝构造和移动构造
![Alt text](image.png)
2.  为什么需要移动构造？
为什么要这么费力地添加移动构造函数呢? 完全可以选择改变GetTemp的接口，比如直接传一个引用或者指针到GetTemp的参数中去，效果应该也不差。其实从性能上来讲，这样的做法确实毫无问题，甚至只好不差
Answer:函数返回临时变量的好处就是不需要声明变量，也不需要知道生命期。程序员只需要按照最自然的方式，使用最简单的语句就可以完成大量的工作。
3. ReturnRvalue函数返回的右值在表达式语句结束后，其生命也就终结了(通常我们也称其具有表达式生命期),而通过右值引用的声明，该右值又“重获新生”,其生命期将与右值引用类型变量a的生命期一样。只要a还“活着”,该右值临时量将会一直“存活”下去。
4. 在常量左值引用在C++98标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化.常量左值所引用的右值在它的“余生”中只能是只读的
5. **std::move** : 它唯一的功能是将一个左值强制转化为右值引用，继而我们可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转:static_cast<T &&>(lvalue);
6. 默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作。这对实现移动语义来说是不够的。通常情况下，如果需要移动语义，程序员必须自定义移动构造函数
7. 在标准库的头文件<type_traits>里，我们还可以通过一些辅助的模板类来判断一个类型是否是可以移动的。比如is_move_constructible, 使用方法仍然是使用其成员value。比如：cout << is_move_constructible <UnknownType>::value;
8. 有了移动语义，还有一个比较典型的应用是可以实现高性能的置换(swap)函数
```c++
template <class T>
void swap(T& a, Ta b){
    T tmp(move(a));
    a = move(b);
    b = move(tmp);
}
```
9. 对于移动构造函数来说，抛出异常有时是件危险的事情。因为可能移动语义还没完成，一个异常却抛出来了，这就会导致一些指针就成为悬挂指针。通过为其添加一个noexcept关键字，可以保证移动构造函数中抛出来的异常会直接调用terminate程序终止运行；
我们还可以用一个std::move_if_noexcept的模板函数替代move函数。该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有noexcept关键字时，返回一个右值引用，从而使变量可以使用移动语义。事实上，move_if _noexcept是以牺牲性能保证安全的一种做法
10 **完美转发** 所谓完美转发(perfect forwarding),是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。
![Alt text](image-1.png)
```c++
template <typename T>
void IamForwording(T && t){
    IrunCodeActually(forward(t));
}
```
这样一来，就减少了一些函数版本的重复(const和非const版本的重复),并能够充分利用移动语义。无论从运行性能的提高还是从代码编写的简化上，完美转发都堪称完美

### 常量表达式
1. const描述的都是一些“运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是const关键字无法保证的
2. C++11中对编译时期常量的回答是constexpr,即常量表达式（在函数表达式前加上constexpr关键字即可），可实现在编译时期对表达式进行值计算
3. 常量表达式函数限制：
    1. 函数体只有单一的return返回语句。
    2. 函数必须返回值(不能是void函数)。
    3. 在使用前必须已有定义。
    4. return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式。
4. 由constexpr关键字修饰的“变量”c和f,这样声明的变量就是所谓的常量表达式值
```c++
const int i - 1;
constexpr int j= 1;
```
如果i在全局名字空间中，编译器一定会为i产生数据。而对于j,如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值
5. C++11标准中，constexpr关键字是不能用于修饰自定义类型的定义的。正确地做法是，定义自定义常量构造函数
```c++
struct MyType {
    constexpr MyType(int x):i(x) {}
    int i;
};
constexpr MyType mt = {0};
```
常量表达式的构造函数也有使用上的约束，主要的有以下两点：1. 函数体必须为空。 2. 初始化列表只能由常量表达式来赋值。
当然，这里还需要注意的是，虽然我们声明的是常量表达式构造函数，但是其编译时的"常量性"则体现在类型上